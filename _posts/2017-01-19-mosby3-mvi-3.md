---
layout: post
published: false
title: Reactive Apps with Model-View-Intent - Part3 - State Reducer
mathjax: false
featrued: false
comments: true
headline: Reactive Apps with Model-View-Intent - Part3 - State Reducer
categories:
  - Android
tags: [android, java]
---
In the [previous part](http://hannesdorfmann.com/android/mosby3-mvi-2) we have shown how to implement a simple screen with the **M**odel-**V**iew-**I**ntent pattern and a unidirectional data flow. In this blog post we are going to build a more complex screen with MVI with a state reducer.

If you haven't read [part 2](http://hannesdorfmann.com/android/mosby3-mvi-2) yet, you should read that before continue with this blog post, because there is described how we connect the View via Presenter with the business logic and how data flows unidirectional.

Now let's build a more complex screen like this:

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/WWeRn0tMoXM" frameborder="0" allowfullscreen></iframe>
</p>

As you see in the video above this screen displays a list of items (products) grouped by category. The app only displays 3 items for each category  and the user can click on a load more button to load more items from that category (makes a http request). Additionally, the user can do pull-to-refresh and once the user has scrolled down the list more items are loaded (pagination). And of course all this actions can be executed simultaneously and each of them could also fail (i.e. no internet connection).

Let's implement this step by step. First, let's define the View interface.

{% highlight java %}
public interface HomeView {

  /**
   * The intent to load the first page
   *
   * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning.
   */
  public Observable<Boolean> loadFirstPageIntent();

  /**
   * The intent to load the next page (pagination)
   *
   * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning.
   */
  public Observable<Boolean> loadNextPageIntent();

  /**
   * The intent to react on pull-to-refresh
   *
   * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning.
   */
  public Observable<Boolean> pullToRefreshIntent();

  /**
   * The intent to load more items from a given category
   *
   * @return Observable with the name of the category
   */
  public Observable<String> loadAllProductsFromCategoryIntent();

  /**
   * Renders the viewState
   */
  public void render(HomeViewState viewState);
}
{% endhighlight %}
The concrete implementation is pretty straight forward and therefore I won't show the code here.
The code can be found [here](https://github.com/sockeqwe/mosby/blob/master/sample-mvi/src/main/java/com/hannesdorfmann/mosby3/sample/mvi/view/home/HomeFragment.java). Next, let's focus on the model. As already said in previous posts the Model should reflect all those possible states. So let's introduce a Model called **HomeViewState**:

{% highlight java %}
public final class HomeViewState {

  private final boolean loadingFirstPage; // Show the loading indicator instead of recyclerView
  private final Throwable firstPageError; // Show an error view if != null
  private final List<FeedItem> data;   // The items displayed in the recyclerview
  private final boolean loadingNextPage; // Shows the loading indicator for pagination
  private final Throwable nextPageError; // if != null, shows error toast that pagination failed
  private final boolean loadingPullToRefresh; // Shows the pull-to-refresh indicator
  private final Throwable pullToRefreshError; // if != null, shows error toast that pull-to-refresh failed

   // ... constructor ...
   // ... getters  ...
}
 {% endhighlight %}

Note that **FeedItem** is just a interface every item has to implement that is displayable by the RecyclerView. For example **Product implements FeedItem**. Also the category title displayed in the recycler **SectionHeader implements FeedItem** is a FeedItem.  The UI element that indicates that more items of that category can be loaded is a FeedItem:

{% highlight java %}
public class AdditionalItemsLoadable implements FeedItem {
  private final int moreItemsAvailableCount;
  private final String categoryName;
  private final boolean loading; // if true then loading items is in progress
  private final Throwable loadingError; // indicates an error has occurred while loading

   // ... constructor ...
   // ... getters  ...
{% endhighlight %}

And last but not least there is a component **HomeFeedLoader** responsible to load **FeedItem**:

{% highlight java %}
public class HomeFeedLoader {

  // Typically triggered by pull-to-refresh
  public Observable<List<FeedItem>> loadNewestPage() { ...  }

  //Loads the first page
  public Observable<List<FeedItem>> loadFirstPage() { ... }

  // loads the next page (pagination)
  public Observable<List<FeedItem>> loadNextPage() { ... }

  // loads additional products of a certain category
  public Observable<List<Product>> loadProductsOfCategory(String categoryName) { ... }
}
{% endhighlight %}

Now let's connect the dots step by step in our Presenter. Please note that some code shown here as part of the Presenter should rather be moved into a Interactor in a real world application.
First, lets start with loading the initial data:

{% highlight java %}
class HomePresenter extends MviBasePresenter<HomeView, HomeViewState> {

  private final HomeFeedLoader feedLoader;

  @Override protected void bindIntents() {

    //
    // In a real app this code would rather be moved to an Interactor
    //
    Observable<HomeViewState> loadFirstPage = intent(HomeView::loadFirstPageIntent)
        .flatMap(ignored -> feedLoader.loadFirstPage()
            .map(items -> new HomeViewState(items, false, null) )
            .startWith(items -> new HomeViewState(emptyList, true, null) )
            .onErrorReturn(error -> new HomeViewState(emptyList, false, error))

    subscribeViewState(loadFirstPage, HomeView::render);
  }
}
{% endhighlight %}

So far so good. Now let's try to add support for pull-to-refresh.


{% highlight java %}
class HomePresenter extends MviBasePresenter<HomeView, HomeViewState> {

  private final HomeFeedLoader feedLoader;

  @Override protected void bindIntents() {

    //
    // In a real app this code would rather be moved to an Interactor
    //
    Observable<HomeViewState> loadFirstPage = ... ;

    Observable<HomeViewState> pullToRefresh = intent(HomeView::pullToRefreshIntent)
        .flatMap(ignored -> feedLoader.loadNewestPage()
            .map( items -> new HomeViewState(...))
            .startWith(new HomeViewState(...))
            .onErrorReturn(error -> new HomeViewState(...)));

    Observable<HomeViewState> allIntents = Observable.merge(loadFirstPage, pullToRefresh);

    subscribeViewState(allIntents, HomeView::render);
  }
}
{% endhighlight %}
<center><small>Use Observable.merge() to merge together multiple intents</small></center>

But wait: **feedLoader.loadNewestPage()** only returns newer items, but what about the previous items we have already loaded?
In "traditional" MVP one would call something like **view.addNewItems(newItems)** but we have already discussed in [part 1](http://hannesdorfmann.com/android/mosby3-mvi-1) why this is a bad idea ("The State Problem").
The problem we are facing now is that pull-to-refresh depends on the previous HomeViewState.

**Ladies and Gentleman, please give a warm welcome to the STATE REDUCER**


![MVI](/images/mvi-mosby3/standingovation3.gif)

State Reducer is a concept from functional programming that takes the previous state as input and computes a new state from the out put like this:

{% highlight java %}
public State reduce( State previous, Foo foo ){
  State newState;
  // ... compute the new State ...
  return newState;
}
{% endhighlight %}

The idea is that such a reduce() function combines the previous state with foo to compute a new state. foo typically represents the changes we want to apply to the previous state.
In our case we want to "reduce" the previous HomeViewState (originally computed from loadFirstPageIntent) with the result from pull-to-refresh. Guess what, RxJava has an operator for that called **scan()**. Let's refactor our code a little bit.
We have to introduce another class representing the partial change (the thing we have called Foo) in the previous code snipped) that will be used to compute the new state.

{% highlight java %}
class HomePresenter extends MviBasePresenter<HomeView, HomeViewState> {

  private final HomeFeedLoader feedLoader;

  @Override protected void bindIntents() {

    //
    // In a real app this code would rather be moved to an Interactor
    //

    Observable<HomeViewState> loadFirstPage = intent(HomeView::loadFirstPageIntent)
        .flatMap(ignored -> feedLoader.loadFirstPage()
            .map(items -> new PartialState.FirstPageData(items) )
            .startWith(items -> new PartialState.FirstPageLoading(true) )
            .onErrorReturn(error -> new PartialState.FirstPageError(error))

    Observable<HomeViewState> pullToRefresh = intent(HomeView::pullToRefreshIntent)
        .flatMap(ignored -> feedLoader.loadNewestPage()
            .map( items -> new PartialState.PullToRefreshData(items)
            .startWith(new PartialState.PullToRefreshLoading(true)))
            .onErrorReturn(error -> new PartialState.PullToRefreshError(error)));

    Observable<PartialState> allIntents = Observable.merge(loadFirstPage, pullToRefresh);
    HomeViewState initialState = ... ; // Show loading first page
    Observable<HomeViewState> stateObservable = allIntents.scan(initialState, this::viewStateReduce)

    subscribeViewState(stateObservable, HomeView::render);
  }

  private HomeViewState viewStateReduce(HomeViewState previousState, PartialState changes){
    ...
  }
}
{% endhighlight %}

So what we did here is, that each Intent now returns an Observable<PartialState> rather then directly HomeState.
Then we merge them all into one observable stream with **Observable.merge()** and finally apply the reducer function (**Observable.scan()**).
Basically what this means is that, whenever the user starts an intent, this intent will produce **PartialState** objects which then will be "reduced" to a **HomeViewState** that then eventually will be displayed in the View (HomeView.render(HomeViewState)).
The only missing part is the state reducer function itself. The HomeViewState class itself hasn't changed (scroll up to see the class definition), but we have added a Builder (Builder pattern) so that we can create new HomeViewState Objects in a convinient way.
So let's implement the state reducer function:

{% highlight java %}
private HomeViewState viewStateReduce(HomeViewState previousState, PartialState changes){
    if (changes instanceof PartialState.FirstPageLoading)
        return previousState.toBuilder() // creates a new copy by taking the internal values of previousState
        .firstPageLoading(true) // show ProgressBar
        .firstPageError(null) // don't show error view
        .build()

    if (changes instanceof PartialState.FirstPageError)
     return previousState.builder()
         .firstPageLoading(false)
         .firstPageError(((PartialState.FirstPageError) changes).getError())
         .build();

     if (changes instanceof PartialState.FirstPageLoaded)
       return previousState.builder()
           .firstPageLoading(false)
           .firstPageError(null)
           .data(((PartialState.FirstPageLoaded) changes).getData())
           .build();

     if (changes instanceof PartialState.PullToRefreshLoading)
      return previousState.builder()
            .pullToRefreshLoading(true) // Show pull to refresh indicator
            .nextPageError(null)
            .build();


    if (changes instanceof PartialState.PullToRefreshError)
      return previousState.builder()
          .pullToRefreshLoading(false) // Hide pull to refresh indicator
          .pullToRefreshError(((PartialState.PullToRefreshError) changes).getError())
          .build();

    if (changes instanceof PartialState.PullToRefreshData) {
      List<FeedItem> data = new ArrayList<>();
      data.addAll(((PullToRefreshData) changes).getData()); // insert data on top of the list
      data.addAll(previousState.getData());

      return previousState.builder()
        .pullToRefreshLoading(false)
        .pullToRefreshError(null)
        .data(data)
        .build();
    }


}
{% endhighlight %}

Since Java is a strongly typed language we have chosen a type safe approach for our Model class by splitting each "sub-state" in its own class.
Our business logic returns an object of type **SearchViewState** which could be an instance of SearchViewState.Error etc.
This is just a personal preference. We could have also modeled this entirely different, for example:

{% highlight java %}
class SearchViewState {
  Throwable error; // if not null, an error has occurred
  boolean loading; // if true loading data is in progress
  List<Product> result; // if not null this is the result of the search
  boolean SearchNotStartedYet; // if true, we have the search not started yet
}
{% endhighlight %}

Again, how you model your Models is just a matter of personal preferences. If you use the kotlin programming language then sealed classes are a great choice.

Next, let's focus on the Business Logic. Let's introduce a **SearchInteractor** which is responsible to execute the search. As already said the "output" is a **SearchViewState** object.


{% highlight java %}
public class SearchInteractor {
  final SearchEngine searchEngine; // Makes http calls

  public Observable<SearchViewState> search(String searchString) {
    // Empty String, so no search
    if (searchString.isEmpty()) {
      return Observable.just(new SearchViewState.SearchNotStartedYet());
    }

    // search for products
    return searchEngine.searchFor(searchString) // Observable<List<Product>>
        .map(products -> {
          if (products.isEmpty()) {
            return new SearchViewState.EmptyResult(searchString);
          } else {
            return new SearchViewState.SearchResult(searchString, products);
          }
        })
        .startWith(new SearchViewState.Loading())
        .onErrorReturn(error -> new SearchViewState.Error(searchString, error));
  }
}
{% endhighlight %}

Let's take a look at the method signatrue of SearchInteractor.search(): We have **String searchString** as input parameter and **Observable&lt;SearchViewState&gt;** as output. This already hints that we expect that arbitrary many instances of SearchViewState are emitted on this observable stream over time.
 **startWith()** says before we are actually starting the search query (via SearchEngine which executes the http request) we emit **SearchViewState.Loading**.
At the end this will force the View to display a ProgressBar while executing the search.

**onErrorReturn()** catches any Exceptions that may occur while executing the search and emits a **SearchViewState.Error**.
Couldn't we just use the onError callback when we subscribe to this Observable?
This is a common misunderstanding in RxJava: the error callback is meant to be used when the whole observable stream runs into an unrecoverable error and therefore the observable stream terminates.
In our case an error like no active internet connection is not an unrecoverable error.
It is yet just another state represented by our Model. Furthermore, we can move to another state afterwards i.e. once
the an active internet connection is available we can move to the "loading state" represented by
**SearchViewState.Loading** .  So we establish an observable stream from our business logic to our view emitting a changed Model every time the "State" changes.
We certainly don't want to terminate this observable stream on a internet connection error. Therefore, such errors are handled as a State (rather than a fatal error that terminates the stream) which is reflected by the Model and emitted to the observable stream when an error occurs. Usually in MVI the  Model Observable never terminates (never reaches the subscriber's onComplete() or onError() ).

To sum it up: **SearchInteractor** (business logic) offers an observable stream **Observable&lt;SearchViewState&gt;** and emits a new SearchViewState every time the state changes.

Next let's discuss how our View layer looks like. What should the View do? Well, obviously the view should display the Model. We have agreed that the View should have a function like **render(model)**. Additionally, the view should offer a way for other layers to react on user input events. These are called **intents** in MVI. In our case there is only one intent: the user can search for a product by typing a String into a input field. We implement MVI in a similar way to MVP. It is good practice in MVP to define a interface for the View layer so let's do this in MVI too.

{% highlight java %}
public interface SearchView {

  /**
   * The search intent
   *
   * @return An observable emitting the search query text
   */
  Observable<String> searchIntent();

  /**
   * Renders the View
   *
   * @param viewState The current viewState state that should be displayed
   */
  void render(SearchViewState viewState);
}
{% endhighlight %}

In this case our View only offers one intent but in general a View could offer multiple intents. In [part 1](http://hannesdorfmann.com/android/mosby3-mvi-1) we have discussed why a single render() function is a nice approach, if it is unclear why we should prefer a single render() you should read part 1 again (or leave a comment below; see also comment section in part 1). Before we start with the concrete implementation of the View layer, let's take a look how the final result should look like:

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/f0U887qmxMM" frameborder="0" allowfullscreen></iframe>
</p>


{% highlight java %}
public class SearchFragment extends Fragment implements SearchView {

  @BindView(R.id.searchView) android.widget.SearchView searchView;
  @BindView(R.id.container) ViewGroup container;
  @BindView(R.id.loadingView) View loadingView;
  @BindView(R.id.errorView) TextView errorView;
  @BindView(R.id.recyclerView) RecyclerView recyclerView;
  @BindView(R.id.emptyView) View emptyView;
  private SearchAdapter adapter;

  @Override public Observable<String> searchIntent() {
    return RxSearchView.queryTextChanges(searchView) // Thanks Jake Wharton :)
        .filter(queryString -> queryString.length() > 3 || queryString.length() == 0)
        .debounce(500, TimeUnit.MILLISECONDS);
  }

  @Override public void render(SearchViewState viewState) {
    if (viewState instanceof SearchViewState.SearchNotStartedYet) {
      renderSearchNotStarted();
    } else if (viewState instanceof SearchViewState.Loading) {
      renderLoading();
    } else if (viewState instanceof SearchViewState.SearchResult) {
      renderResult(((SearchViewState.SearchResult) viewState).getResult());
    } else if (viewState instanceof SearchViewState.EmptyResult) {
      renderEmptyResult();
    } else if (viewState instanceof SearchViewState.Error) {
      Timber.e(((SearchViewState.Error) viewState).getError());
      renderError();
    } else {
      throw new IllegalArgumentException("Don't know how to render viewState " + viewState);
    }
  }

  private void renderResult(List<Product> result) {
    TransitionManager.beginDelayedTransition(container);
    recyclerView.setVisibility(View.VISIBLE);
    loadingView.setVisibility(View.GONE);
    emptyView.setVisibility(View.GONE);
    errorView.setVisibility(View.GONE);
    adapter.setProducts(result);
    adapter.notifyDataSetChanged();
  }

  private void renderSearchNotStarted() {
    TransitionManager.beginDelayedTransition(container);
    recyclerView.setVisibility(View.GONE);
    loadingView.setVisibility(View.GONE);
    errorView.setVisibility(View.GONE);
    emptyView.setVisibility(View.GONE);
  }

  private void renderLoading() {
    TransitionManager.beginDelayedTransition(container);
    recyclerView.setVisibility(View.GONE);
    loadingView.setVisibility(View.VISIBLE);
    errorView.setVisibility(View.GONE);
    emptyView.setVisibility(View.GONE);
  }

  private void renderError() {
    TransitionManager.beginDelayedTransition(container);
    recyclerView.setVisibility(View.GONE);
    loadingView.setVisibility(View.GONE);
    errorView.setVisibility(View.VISIBLE);
    emptyView.setVisibility(View.GONE);
  }

  private void renderEmptyResult() {
    TransitionManager.beginDelayedTransition(container);
    recyclerView.setVisibility(View.GONE);
    loadingView.setVisibility(View.GONE);
    errorView.setVisibility(View.GONE);
    emptyView.setVisibility(View.VISIBLE);
  }
}
{% endhighlight %}

The **render(SearchViewState)** method should be self explaining. In **searchIntent()** we use
Jake Wharton's [RxBindings](https://github.com/JakeWharton/RxBinding) library that provides
RxJava bindings like Observable for Android UI widget.
RxSearchView.queryText() creates an Observable&lt;String&gt; that emits the search string every
time the user types something into the EditText UI widget.
We use filter() to only start a search query if the
user has typed in more than 3 characters and we don't want hit the backend every time the user
types in a new character but rather we want to wait until the user has finished typing (debounce() waits 500 milliseconds to determine if the user has finished typing).

So we know that the "input" for this screen is the searchIntent() and that render() is the "output". How do we get from "input" to "output"?
The following video visualizes that:

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oo0SBtqKhMw" frameborder="0" allowfullscreen></iframe>
</p>

The remaining question is who or how do we connect the View's intent with the business logic?
If you take a closer look at the video from above you will see that there is a **flatMap()** operator in the middle.
This already hints us that there is an additional component involved we haven't talked about yet: a **Presenter**. The Presenter is responsible to connect the dots similar as we would use a presenter in MVP.

{% highlight java %}
public class SearchPresenter extends MviBasePresenter<SearchView, SearchViewState> {
  private final SearchInteractor searchInteractor;

  @Override protected void bindIntents() {
    Observable<SearchViewState> search =
        intent(SearchView::searchIntent)
            .switchMap(searchInteractor::search) // I have used flatMap() in the video above, but switchMap() makes more sense here
            .observeOn(AndroidSchedulers.mainThread());

    subscribeViewState(search, SearchView::render);
  }
}
{% endhighlight %}

<small>Please node that SearchView::searchIntent is just a Java 8 shorthand for searchView.searchIntent()</small>

What is **MviBasePresenter** and what are **intent()** and **subscribeViewState()**?
This class is part of a library I have written called [Mosby](https://github.com/sockeqwe/mosby) (Mosby 3.0 has a MVI module). This blog post is not about Mosby but I want briefly talk about how MviBasePresenter works to convince you that there is no black magic involved although I have to admit that at first glance it looks like that.
Let's start with lifecycle: MviBasePresenter doesn't really have a lifecyle.
There is a  **bindIntent()** method where you bind the intents from the View to the business logic. Typically, you use flatMap() or switchMap() or concatMap() to "forward" an intent to the business logic.
This method is invoked only the first time a View is attached to the Presenter.
It's not invoked again when the View gets reattached (i.e. after a screen orientation change).

That may sounds a bit strange and one may ask: "Does MviBasePresenter even survive screen orientation changes and if yes how does Mosby ensures that the observable stream remains without leaking the memory?"
This is what **intent()** and **subscribeViewState()** are for. **intent()** creates a **PublishSubject** internally and uses that one as "gateway" to your business logic.
So actually this PublishSubject is subscribing to View's intent Observable. Calling intent(o1) actually returns a PublishSubject which is subscribed to o1.

On orientation change Mosby detaches the View from Presenter but only unsubscribes this internal PublishSubject temporarily from the View and resubscribes the PublishSubject to the View's intent when the view gets reattached to the presenter.

**subscribeViewState()** does the same but the other way around (Presenter to View communication). It creates internally a **BehaviorSubject** as "gateway" from business logic to View. Since it's a BehaviorSubject we can receive "model updates" from business logic even if no view is attached at the moment (i.e. View is on the back stack). BehaviorSubjects always keep the latest value it has received and replays that once the View gets reattached.

The rule is simple: use intent() to "wrap" any intent of the view. Use subscribeViewState() instead of Observable.subscribe(...).


![MVI](/images/mvi-mosby3/MviBasePresenter.png)

The counter part to bindIntent() is  **unbindIntents()** which is invoked exactly one time the View is destroyed permanently. For instance putting a fragment on the back stack doesn't destroy the View permanently, but finishing an Activity does.
Since intent() and subscribeViewState() already take care of subscription management you only barely need to implement unbindIntents().

What about other lifecycle events like **onPause()** or **onResume()**? I still think that [Presenters don't need lifecycle Events](http://hannesdorfmann.com/android/presenters-dont-need-lifecycle). However, if you really think you need them you can simply see a lifecycle event like onPause() as an intent. Your View could offer a **pauseIntent()** which is triggered by android lifecycle instead of a user interaction intent like clicking on a button. But both are valid intents.

## Conclusion
In this second part we have talked about the basics of Model-View-Intent and implemented a very simple screen by using MVI to get our feet wet. Maybe this example is too simple so that you don't fully see yet the benefits of MVI pattern, a Model which represents State and the unidirectional data flow compared to "traditional" MVP or MVVM. There is nothing wrong with MVP or MVVM and I'm not saying that MVI is better than other architectural patterns. However, I think that MVI helps us to write elegant code for complex problems as we will see in the next part (Part 3) of this blog series when we are going to talk about state reducers.
